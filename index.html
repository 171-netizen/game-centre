<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Ink Turf Rush</title>
  <style>
    body {
      margin: 0;
      background: #111;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      overflow: hidden;
      font-family: Arial, sans-serif;
      color: #fff;
    }
    canvas {
      background: #1b1b2b;
      border: 3px solid #5cff7a;
      box-shadow: 0 0 20px #5cff7a;
    }
    #info {
      position: absolute;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      color: #5cff7a;
      font-size: 18px;
      text-shadow: 0 0 5px #000;
    }
  </style>
</head>
<body>
<div id="info">A/D or ←/→ to move • W or ↑ to jump • J or Z to shoot</div>
<canvas id="game" width="800" height="400"></canvas>
<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

const W = canvas.width;
const H = canvas.height;

// Player
const player = {
  x: 100,
  y: 260,
  w: 32,
  h: 40,
  vy: 0,
  speed: 4,
  onGround: false,
  facing: 1,
  ink: 100,
  maxInk: 100,
  reloadRate: 0.15
};

// World
const gravity = 0.7;
const groundY = 320;
let scrollX = 0;

// Ink + turf
let inkShots = [];
let inkPuddles = []; // {x, y, w, h, owner:'player'}
let turfScore = 0;

// Enemies
let enemies = [];
const enemyTemplate = {
  w: 30,
  h: 40,
  maxHealth: 100,
  speed: 1.5
};

// Game state
let keys = {};
let frame = 0;
let gameTime = 60 * 60; // 60 seconds at 60fps
let gameOver = false;

// Input
document.addEventListener('keydown', (e) => {
  keys[e.key.toLowerCase()] = true;
});
document.addEventListener('keyup', (e) => {
  keys[e.key.toLowerCase()] = false;
});

// Helpers
function randRange(a, b) {
  return a + Math.random() * (b - a);
}

// Init enemies
function spawnEnemy() {
  const x = scrollX + W + randRange(50, 200);
  enemies.push({
    x,
    y: groundY - enemyTemplate.h,
    w: enemyTemplate.w,
    h: enemyTemplate.h,
    health: enemyTemplate.maxHealth,
    maxHealth: enemyTemplate.maxHealth,
    speed: enemyTemplate.speed,
    dir: -1,
    inked: 0 // how long they are slowed/inked
  });
}

for (let i = 0; i < 4; i++) {
  spawnEnemy();
}

// Update
function update() {
  if (gameOver) return;

  frame++;
  gameTime--;
  if (gameTime <= 0) {
    gameOver = true;
  }

  // Player input
  let moveDir = 0;
  if (keys['a'] || keys['arrowleft']) moveDir -= 1;
  if (keys['d'] || keys['arrowright']) moveDir += 1;

  if (moveDir !== 0) {
    player.facing = moveDir;
    player.x += moveDir * player.speed;
  }

  // World scroll: keep player near center
  const centerZone = W * 0.4;
  if (player.x > centerZone) {
    scrollX += player.x - centerZone;
    player.x = centerZone;
  }
  if (player.x < 80 && scrollX > 0) {
    const diff = 80 - player.x;
    scrollX = Math.max(0, scrollX - diff);
    player.x = 80;
  }

  // Jump
  if ((keys['w'] || keys['arrowup']) && player.onGround) {
    player.vy = -13;
    player.onGround = false;
  }

  // Gravity
  player.vy += gravity;
  player.y += player.vy;

  if (player.y + player.h >= groundY) {
    player.y = groundY - player.h;
    player.vy = 0;
    player.onGround = true;
  }

  // Ink reload
  player.ink = Math.min(player.maxInk, player.ink + player.reloadRate);

  // Shoot
  if ((keys['j'] || keys['z']) && frame % 8 === 0 && player.ink >= 5) {
    shootInk();
    player.ink -= 5;
  }

  // Update ink shots
  for (let i = inkShots.length - 1; i >= 0; i--) {
    const s = inkShots[i];
    s.x += s.vx;
    s.y += s.vy;
    s.vy += 0.2; // slight arc

    // Hit ground → create puddle
    if (s.y + s.r >= groundY) {
      createInkPuddle(s.x - 10, groundY - 8, 40, 8);
      inkShots.splice(i, 1);
      continue;
    }

    // Hit enemies
    for (let e of enemies) {
      if (
        s.x > e.x - scrollX &&
        s.x < e.x - scrollX + e.w &&
        s.y > e.y &&
        s.y < e.y + e.h
      ) {
        e.health -= 25;
        e.inked = 60; // 1 second of slow
        inkShots.splice(i, 1);
        break;
      }
    }
  }

  // Update ink puddles (turf scoring)
  for (let p of inkPuddles) {
    // If puddle is on screen, add turf slowly
    if (p.x + p.w > scrollX && p.x < scrollX + W) {
      turfScore += 0.02;
    }
  }

  // Update enemies
  for (let e of enemies) {
    let speed = e.speed;
    if (e.inked > 0) {
      speed *= 0.4;
      e.inked--;
    }

    e.x += e.dir * speed;

    // Simple patrol: turn around at edges of screen area
    if (e.x < scrollX + 50) {
      e.dir = 1;
    }
    if (e.x + e.w > scrollX + W - 50) {
      e.dir = -1;
    }

    // Check if enemy stands on ink → slow + turf bonus
    for (let p of inkPuddles) {
      if (
        e.x + e.w > p.x &&
        e.x < p.x + p.w &&
        e.y + e.h >= p.y &&
        e.y + e.h <= p.y + p.h + 10
      ) {
        e.inked = 30;
        turfScore += 0.05;
      }
    }

    // Enemy dead → respawn further ahead
    if (e.health <= 0) {
      turfScore += 10;
      respawnEnemy(e);
    }
  }
}

function shootInk() {
  const speed = 8;
  inkShots.push({
    x: player.x + (player.facing === 1 ? player.w : 0),
    y: player.y + player.h / 2,
    vx: player.facing * speed,
    vy: -1,
    r: 6
  });
}

function createInkPuddle(x, y, w, h) {
  // Merge with nearby puddles to avoid spam
  inkPuddles.push({ x: x + scrollX, y, w, h, owner: 'player' });
}

function respawnEnemy(e) {
  e.x = scrollX + W + randRange(100, 300);
  e.y = groundY - e.h;
  e.health = e.maxHealth;
  e.dir = -1;
  e.inked = 0;
}

// Draw
function draw() {
  ctx.clearRect(0, 0, W, H);

  // Background
  const grad = ctx.createLinearGradient(0, 0, 0, H);
  grad.addColorStop(0, '#141428');
  grad.addColorStop(1, '#050509');
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, W, H);

  // Ground
  ctx.fillStyle = '#202830';
  ctx.fillRect(0, groundY, W, H - groundY);

  // Ink puddles (turf)
  for (let p of inkPuddles) {
    const screenX = p.x - scrollX;
    if (screenX + p.w < 0 || screenX > W) continue;
    ctx.fillStyle = '#33ff99';
    ctx.fillRect(screenX, p.y, p.w, p.h);
  }

  // Player
  ctx.fillStyle = '#ff66ff';
  ctx.fillRect(player.x, player.y, player.w, player.h);

  // Player gun
  ctx.fillStyle = '#ffd6ff';
  const gunX = player.facing === 1 ? player.x + player.w : player.x - 10;
  ctx.fillRect(gunX, player.y + 10, 10, 8);

  // Ink shots
  ctx.fillStyle = '#33ffcc';
  for (let s of inkShots) {
    ctx.beginPath();
    ctx.arc(s.x, s.y, s.r, 0, Math.PI * 2);
    ctx.fill();
  }

  // Enemies
  for (let e of enemies) {
    const ex = e.x - scrollX;
    if (ex + e.w < 0 || ex > W) continue;

    // Body
    ctx.fillStyle = e.inked > 0 ? '#5555ff' : '#ff4444';
    ctx.fillRect(ex, e.y, e.w, e.h);

    // Health bar
    const barW = e.w;
    const ratio = e.health / e.maxHealth;
    ctx.fillStyle = '#000';
    ctx.fillRect(ex, e.y - 8, barW, 5);
    ctx.fillStyle = '#00ff00';
    ctx.fillRect(ex, e.y - 8, barW * ratio, 5);
  }

  // UI: ink, turf, time
  ctx.fillStyle = '#ffffff';
  ctx.font = '16px Arial';
  ctx.fillText('Ink: ' + Math.round(player.ink), 10, 20);
  ctx.fillText('Turf: ' + Math.round(turfScore), 10, 40);
  ctx.fillText('Time: ' + Math.max(0, Math.floor(gameTime / 60)) + 's', 10, 60);

  if (gameOver) {
    ctx.fillStyle = '#ffffff';
    ctx.font = '32px Arial';
    ctx.fillText('Turf Rush Over!', W / 2 - 120, H / 2 - 10);
    ctx.font = '20px Arial';
    ctx.fillText('Final Turf: ' + Math.round(turfScore), W / 2 - 90, H / 2 + 20);
    ctx.fillText('Refresh page to play again', W / 2 - 120, H / 2 + 50);
  }
}

function loop() {
  update();
  draw();
  requestAnimationFrame(loop);
}

loop();
</script>
</body>
</html>
